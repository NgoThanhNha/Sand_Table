CCS PCM C Compiler, Version 5.025, 10889               20-Jun-23 16:21

               Filename:   D:\Projects\__Bluetooth_Car_PIC16F887_Rev1.0\Programming\Remote_Controller_BlueCar_Rev1.0\main.lst

               ROM used:   828 words (10%)
                           Largest free fragment is 2048
               RAM used:   14 (4%) at main() level
                           67 (18%) worst case
               Stack used: 4 locations
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   29E
0003:  NOP
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  42
0009:  RETLW  6C
000A:  RETLW  75
000B:  RETLW  65
000C:  RETLW  74
000D:  RETLW  6F
000E:  RETLW  6F
000F:  RETLW  74
0010:  RETLW  68
0011:  RETLW  20
0012:  RETLW  43
0013:  RETLW  61
0014:  RETLW  72
0015:  RETLW  00
0016:  BCF    0A.0
0017:  BCF    0A.1
0018:  BCF    0A.2
0019:  ADDWF  02,F
001A:  RETLW  50
001B:  RETLW  49
001C:  RETLW  43
001D:  RETLW  31
001E:  RETLW  36
001F:  RETLW  46
0020:  RETLW  38
0021:  RETLW  38
0022:  RETLW  37
0023:  RETLW  00
*
0039:  MOVF   5A,W
003A:  ANDLW  07
003B:  MOVWF  77
003C:  RRF    5A,W
003D:  MOVWF  78
003E:  RRF    78,F
003F:  RRF    78,F
0040:  MOVLW  1F
0041:  ANDWF  78,F
0042:  MOVF   78,W
0043:  ADDWF  5C,W
0044:  MOVWF  04
0045:  BCF    03.7
0046:  BTFSC  5D.0
0047:  BSF    03.7
0048:  CLRF   78
0049:  INCF   78,F
004A:  INCF   77,F
004B:  GOTO   04D
004C:  RLF    78,F
004D:  DECFSZ 77,F
004E:  GOTO   04C
004F:  MOVF   5B,F
0050:  BTFSC  03.2
0051:  GOTO   055
0052:  MOVF   78,W
0053:  IORWF  00,F
0054:  GOTO   058
0055:  COMF   78,F
0056:  MOVF   78,W
0057:  ANDWF  00,F
0058:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=4MHz) 
*
0024:  MOVLW  57
0025:  MOVWF  04
0026:  BCF    03.7
0027:  MOVF   00,W
0028:  BTFSC  03.2
0029:  GOTO   038
002A:  MOVLW  01
002B:  MOVWF  78
002C:  CLRF   77
002D:  DECFSZ 77,F
002E:  GOTO   02D
002F:  DECFSZ 78,F
0030:  GOTO   02C
0031:  MOVLW  4A
0032:  MOVWF  77
0033:  DECFSZ 77,F
0034:  GOTO   033
0035:  GOTO   036
0036:  DECFSZ 00,F
0037:  GOTO   02A
0038:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
02C0:  BCF    03.6
02C1:  CLRF   20
02C2:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define LCD_ENABLE_PIN PIN_D0 
.................... #define LCD_RS_PIN PIN_D1 
.................... #define LCD_RW_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D7 
.................... #define LCD_DATA5 PIN_D6 
.................... #define LCD_DATA6 PIN_D5 
.................... #define LCD_DATA7 PIN_D4 
....................  
.................... #define Button_Up       PIN_C0                           
.................... #define Button_Down     PIN_C1  
.................... #define Button_Left     PIN_C2                            
.................... #define Button_Right    PIN_C3   
.................... #int_RDA 
....................  
.................... unsigned int8 recevieData = 0; 
.................... unsigned int8 metalCheck = 0; 
....................  
....................  
.................... void digitalWrite(char Pin, unsigned int1 Logic){ 
....................    if(Logic == 1){ 
*
0059:  DECFSZ 59,W
005A:  GOTO   06A
....................       output_high(Pin); 
005B:  MOVF   58,W
005C:  MOVWF  5A
005D:  MOVLW  01
005E:  MOVWF  5B
005F:  CLRF   5D
0060:  CLRF   5C
0061:  CALL   039
0062:  MOVF   58,W
0063:  MOVWF  5A
0064:  CLRF   5B
0065:  CLRF   5D
0066:  MOVLW  80
0067:  MOVWF  5C
0068:  CALL   039
....................    } 
0069:  GOTO   077
....................    else{ 
....................       output_low(Pin); 
006A:  MOVF   58,W
006B:  MOVWF  5A
006C:  CLRF   5B
006D:  CLRF   5D
006E:  CLRF   5C
006F:  CALL   039
0070:  MOVF   58,W
0071:  MOVWF  5A
0072:  CLRF   5B
0073:  CLRF   5D
0074:  MOVLW  80
0075:  MOVWF  5C
0076:  CALL   039
....................    } 
0077:  RETURN
.................... } 
....................  
.................... //-----------------------------------------LCD Function------------------------------------------ 
.................... void LCD_sendCmd(unsigned int8 cmdData){ 
....................    digitalWrite(LCD_RS_PIN, 0); 
0078:  MOVLW  41
0079:  MOVWF  58
007A:  CLRF   59
007B:  CALL   059
....................    digitalWrite(LCD_RW_PIN, 0); 
007C:  MOVLW  42
007D:  MOVWF  58
007E:  CLRF   59
007F:  CALL   059
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
0080:  MOVLW  40
0081:  MOVWF  58
0082:  CLRF   59
0083:  CALL   059
....................     
....................    // Send higher 4 bit: 
....................    digitalWrite(LCD_DATA7, ((cmdData >> 7) & 0x01)); 
0084:  CLRF   77
0085:  BTFSC  56.7
0086:  BSF    77.0
0087:  MOVF   77,W
0088:  ANDLW  01
0089:  MOVWF  57
008A:  MOVLW  44
008B:  MOVWF  58
008C:  MOVF   57,W
008D:  MOVWF  59
008E:  CALL   059
....................    digitalWrite(LCD_DATA6, ((cmdData >> 6) & 0x01)); 
008F:  SWAPF  56,W
0090:  MOVWF  77
0091:  RRF    77,F
0092:  RRF    77,F
0093:  MOVLW  03
0094:  ANDWF  77,F
0095:  MOVF   77,W
0096:  ANDLW  01
0097:  MOVWF  57
0098:  MOVLW  45
0099:  MOVWF  58
009A:  MOVF   57,W
009B:  MOVWF  59
009C:  CALL   059
....................    digitalWrite(LCD_DATA5, ((cmdData >> 5) & 0x01)); 
009D:  SWAPF  56,W
009E:  MOVWF  77
009F:  RRF    77,F
00A0:  MOVLW  07
00A1:  ANDWF  77,F
00A2:  MOVF   77,W
00A3:  ANDLW  01
00A4:  MOVWF  57
00A5:  MOVLW  46
00A6:  MOVWF  58
00A7:  MOVF   57,W
00A8:  MOVWF  59
00A9:  CALL   059
....................    digitalWrite(LCD_DATA4, ((cmdData >> 4) & 0x01)); 
00AA:  SWAPF  56,W
00AB:  MOVWF  77
00AC:  MOVLW  0F
00AD:  ANDWF  77,F
00AE:  MOVF   77,W
00AF:  ANDLW  01
00B0:  MOVWF  57
00B1:  MOVLW  47
00B2:  MOVWF  58
00B3:  MOVF   57,W
00B4:  MOVWF  59
00B5:  CALL   059
....................    digitalWrite(LCD_ENABLE_PIN, 1); 
00B6:  MOVLW  40
00B7:  MOVWF  58
00B8:  MOVLW  01
00B9:  MOVWF  59
00BA:  CALL   059
....................    delay_us(100); 
00BB:  MOVLW  20
00BC:  MOVWF  77
00BD:  DECFSZ 77,F
00BE:  GOTO   0BD
00BF:  GOTO   0C0
00C0:  NOP
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
00C1:  MOVLW  40
00C2:  MOVWF  58
00C3:  CLRF   59
00C4:  CALL   059
....................    delay_ms(1); 
00C5:  MOVLW  01
00C6:  MOVWF  57
00C7:  CALL   024
....................     
....................    // Send lower 4 bit: 
....................    digitalWrite(LCD_DATA7, ((cmdData >> 3) & 0x01)); 
00C8:  RRF    56,W
00C9:  MOVWF  77
00CA:  RRF    77,F
00CB:  RRF    77,F
00CC:  MOVLW  1F
00CD:  ANDWF  77,F
00CE:  MOVF   77,W
00CF:  ANDLW  01
00D0:  MOVWF  57
00D1:  MOVLW  44
00D2:  MOVWF  58
00D3:  MOVF   57,W
00D4:  MOVWF  59
00D5:  CALL   059
....................    digitalWrite(LCD_DATA6, ((cmdData >> 2) & 0x01)); 
00D6:  RRF    56,W
00D7:  MOVWF  77
00D8:  RRF    77,F
00D9:  MOVLW  3F
00DA:  ANDWF  77,F
00DB:  MOVF   77,W
00DC:  ANDLW  01
00DD:  MOVWF  57
00DE:  MOVLW  45
00DF:  MOVWF  58
00E0:  MOVF   57,W
00E1:  MOVWF  59
00E2:  CALL   059
....................    digitalWrite(LCD_DATA5, ((cmdData >> 1) & 0x01)); 
00E3:  BCF    03.0
00E4:  RRF    56,W
00E5:  ANDLW  01
00E6:  MOVWF  57
00E7:  MOVLW  46
00E8:  MOVWF  58
00E9:  MOVF   57,W
00EA:  MOVWF  59
00EB:  CALL   059
....................    digitalWrite(LCD_DATA4, (cmdData & 0x01)); 
00EC:  MOVF   56,W
00ED:  ANDLW  01
00EE:  MOVWF  57
00EF:  MOVLW  47
00F0:  MOVWF  58
00F1:  MOVF   57,W
00F2:  MOVWF  59
00F3:  CALL   059
....................    digitalWrite(LCD_ENABLE_PIN, 1); 
00F4:  MOVLW  40
00F5:  MOVWF  58
00F6:  MOVLW  01
00F7:  MOVWF  59
00F8:  CALL   059
....................    delay_us(100); 
00F9:  MOVLW  20
00FA:  MOVWF  77
00FB:  DECFSZ 77,F
00FC:  GOTO   0FB
00FD:  GOTO   0FE
00FE:  NOP
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
00FF:  MOVLW  40
0100:  MOVWF  58
0101:  CLRF   59
0102:  CALL   059
....................    delay_ms(1); 
0103:  MOVLW  01
0104:  MOVWF  57
0105:  CALL   024
0106:  RETURN
.................... } 
....................  
.................... void LCD_Initilize(){ 
....................    delay_ms(15); 
0107:  MOVLW  0F
0108:  MOVWF  57
0109:  CALL   024
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
010A:  MOVLW  40
010B:  MOVWF  58
010C:  CLRF   59
010D:  CALL   059
....................     
....................    digitalWrite(LCD_RS_PIN, 0); 
010E:  MOVLW  41
010F:  MOVWF  58
0110:  CLRF   59
0111:  CALL   059
....................    digitalWrite(LCD_RW_PIN, 0); 
0112:  MOVLW  42
0113:  MOVWF  58
0114:  CLRF   59
0115:  CALL   059
....................    digitalWrite(LCD_DATA7, 0); 
0116:  MOVLW  44
0117:  MOVWF  58
0118:  CLRF   59
0119:  CALL   059
....................    digitalWrite(LCD_DATA6, 0); 
011A:  MOVLW  45
011B:  MOVWF  58
011C:  CLRF   59
011D:  CALL   059
....................    digitalWrite(LCD_DATA5, 1); 
011E:  MOVLW  46
011F:  MOVWF  58
0120:  MOVLW  01
0121:  MOVWF  59
0122:  CALL   059
....................    digitalWrite(LCD_DATA4, 1); 
0123:  MOVLW  47
0124:  MOVWF  58
0125:  MOVLW  01
0126:  MOVWF  59
0127:  CALL   059
....................    digitalWrite(LCD_ENABLE_PIN, 1); 
0128:  MOVLW  40
0129:  MOVWF  58
012A:  MOVLW  01
012B:  MOVWF  59
012C:  CALL   059
....................    delay_us(100); 
012D:  MOVLW  20
012E:  MOVWF  77
012F:  DECFSZ 77,F
0130:  GOTO   12F
0131:  GOTO   132
0132:  NOP
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
0133:  MOVLW  40
0134:  MOVWF  58
0135:  CLRF   59
0136:  CALL   059
....................     
....................    delay_ms(5); //Delay 5ms 
0137:  MOVLW  05
0138:  MOVWF  57
0139:  CALL   024
....................     
....................    digitalWrite(LCD_RS_PIN, 0); 
013A:  MOVLW  41
013B:  MOVWF  58
013C:  CLRF   59
013D:  CALL   059
....................    digitalWrite(LCD_RW_PIN, 0); 
013E:  MOVLW  42
013F:  MOVWF  58
0140:  CLRF   59
0141:  CALL   059
....................    digitalWrite(LCD_DATA7, 0); 
0142:  MOVLW  44
0143:  MOVWF  58
0144:  CLRF   59
0145:  CALL   059
....................    digitalWrite(LCD_DATA6, 0); 
0146:  MOVLW  45
0147:  MOVWF  58
0148:  CLRF   59
0149:  CALL   059
....................    digitalWrite(LCD_DATA5, 1); 
014A:  MOVLW  46
014B:  MOVWF  58
014C:  MOVLW  01
014D:  MOVWF  59
014E:  CALL   059
....................    digitalWrite(LCD_DATA4, 1); 
014F:  MOVLW  47
0150:  MOVWF  58
0151:  MOVLW  01
0152:  MOVWF  59
0153:  CALL   059
....................    digitalWrite(LCD_ENABLE_PIN, 1); 
0154:  MOVLW  40
0155:  MOVWF  58
0156:  MOVLW  01
0157:  MOVWF  59
0158:  CALL   059
....................    delay_us(100); 
0159:  MOVLW  20
015A:  MOVWF  77
015B:  DECFSZ 77,F
015C:  GOTO   15B
015D:  GOTO   15E
015E:  NOP
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
015F:  MOVLW  40
0160:  MOVWF  58
0161:  CLRF   59
0162:  CALL   059
....................     
....................    delay_ms(1); 
0163:  MOVLW  01
0164:  MOVWF  57
0165:  CALL   024
....................     
....................    LCD_sendCmd(0x32); 
0166:  MOVLW  32
0167:  MOVWF  56
0168:  CALL   078
....................    delay_ms(1); 
0169:  MOVLW  01
016A:  MOVWF  57
016B:  CALL   024
....................    LCD_sendCmd(0x28); //N = 1, F = 0 
016C:  MOVLW  28
016D:  MOVWF  56
016E:  CALL   078
....................    delay_ms(1); 
016F:  MOVLW  01
0170:  MOVWF  57
0171:  CALL   024
....................    LCD_sendCmd(0x08); 
0172:  MOVLW  08
0173:  MOVWF  56
0174:  CALL   078
....................    delay_ms(1);   
0175:  MOVLW  01
0176:  MOVWF  57
0177:  CALL   024
....................    LCD_sendCmd(0x01); 
0178:  MOVLW  01
0179:  MOVWF  56
017A:  CALL   078
....................    delay_ms(1); 
017B:  MOVLW  01
017C:  MOVWF  57
017D:  CALL   024
....................    LCD_sendCmd(0x06); 
017E:  MOVLW  06
017F:  MOVWF  56
0180:  CALL   078
....................    delay_ms(1); 
0181:  MOVLW  01
0182:  MOVWF  57
0183:  CALL   024
....................    LCD_sendCmd(0x0F); //Display ON, Cursor ON, Blink ON 
0184:  MOVLW  0F
0185:  MOVWF  56
0186:  CALL   078
....................    delay_ms(1); 
0187:  MOVLW  01
0188:  MOVWF  57
0189:  CALL   024
018A:  BCF    0A.3
018B:  BCF    0A.4
018C:  GOTO   2CC (RETURN)
.................... } 
....................  
.................... void LCD_sendChar(unsigned int8 charData){ 
....................    digitalWrite(LCD_RS_PIN, 1); 
*
020C:  MOVLW  41
020D:  MOVWF  58
020E:  MOVLW  01
020F:  MOVWF  59
0210:  CALL   059
....................    digitalWrite(LCD_RW_PIN, 0); 
0211:  MOVLW  42
0212:  MOVWF  58
0213:  CLRF   59
0214:  CALL   059
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
0215:  MOVLW  40
0216:  MOVWF  58
0217:  CLRF   59
0218:  CALL   059
....................     
....................    // Send higher 4 bit: 
....................    digitalWrite(LCD_DATA7, ((charData >> 7) & 0x01)); 
0219:  CLRF   77
021A:  BTFSC  39.7
021B:  BSF    77.0
021C:  MOVF   77,W
021D:  ANDLW  01
021E:  MOVWF  3A
021F:  MOVLW  44
0220:  MOVWF  58
0221:  MOVF   3A,W
0222:  MOVWF  59
0223:  CALL   059
....................    digitalWrite(LCD_DATA6, ((charData >> 6) & 0x01)); 
0224:  SWAPF  39,W
0225:  MOVWF  77
0226:  RRF    77,F
0227:  RRF    77,F
0228:  MOVLW  03
0229:  ANDWF  77,F
022A:  MOVF   77,W
022B:  ANDLW  01
022C:  MOVWF  3A
022D:  MOVLW  45
022E:  MOVWF  58
022F:  MOVF   3A,W
0230:  MOVWF  59
0231:  CALL   059
....................    digitalWrite(LCD_DATA5, ((charData >> 5) & 0x01)); 
0232:  SWAPF  39,W
0233:  MOVWF  77
0234:  RRF    77,F
0235:  MOVLW  07
0236:  ANDWF  77,F
0237:  MOVF   77,W
0238:  ANDLW  01
0239:  MOVWF  3A
023A:  MOVLW  46
023B:  MOVWF  58
023C:  MOVF   3A,W
023D:  MOVWF  59
023E:  CALL   059
....................    digitalWrite(LCD_DATA4, ((charData >> 4) & 0x01)); 
023F:  SWAPF  39,W
0240:  MOVWF  77
0241:  MOVLW  0F
0242:  ANDWF  77,F
0243:  MOVF   77,W
0244:  ANDLW  01
0245:  MOVWF  3A
0246:  MOVLW  47
0247:  MOVWF  58
0248:  MOVF   3A,W
0249:  MOVWF  59
024A:  CALL   059
....................    digitalWrite(LCD_ENABLE_PIN, 1); 
024B:  MOVLW  40
024C:  MOVWF  58
024D:  MOVLW  01
024E:  MOVWF  59
024F:  CALL   059
....................    delay_us(100); 
0250:  MOVLW  20
0251:  MOVWF  77
0252:  DECFSZ 77,F
0253:  GOTO   252
0254:  GOTO   255
0255:  NOP
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
0256:  MOVLW  40
0257:  MOVWF  58
0258:  CLRF   59
0259:  CALL   059
....................    delay_ms(1); 
025A:  MOVLW  01
025B:  MOVWF  57
025C:  CALL   024
....................     
....................    // Send lower 4 bit: 
....................    digitalWrite(LCD_DATA7, ((charData >> 3) & 0x01)); 
025D:  RRF    39,W
025E:  MOVWF  77
025F:  RRF    77,F
0260:  RRF    77,F
0261:  MOVLW  1F
0262:  ANDWF  77,F
0263:  MOVF   77,W
0264:  ANDLW  01
0265:  MOVWF  3A
0266:  MOVLW  44
0267:  MOVWF  58
0268:  MOVF   3A,W
0269:  MOVWF  59
026A:  CALL   059
....................    digitalWrite(LCD_DATA6, ((charData >> 2) & 0x01)); 
026B:  RRF    39,W
026C:  MOVWF  77
026D:  RRF    77,F
026E:  MOVLW  3F
026F:  ANDWF  77,F
0270:  MOVF   77,W
0271:  ANDLW  01
0272:  MOVWF  3A
0273:  MOVLW  45
0274:  MOVWF  58
0275:  MOVF   3A,W
0276:  MOVWF  59
0277:  CALL   059
....................    digitalWrite(LCD_DATA5, ((charData >> 1) & 0x01)); 
0278:  BCF    03.0
0279:  RRF    39,W
027A:  ANDLW  01
027B:  MOVWF  3A
027C:  MOVLW  46
027D:  MOVWF  58
027E:  MOVF   3A,W
027F:  MOVWF  59
0280:  CALL   059
....................    digitalWrite(LCD_DATA4, (charData & 0x01)); 
0281:  MOVF   39,W
0282:  ANDLW  01
0283:  MOVWF  3A
0284:  MOVLW  47
0285:  MOVWF  58
0286:  MOVF   3A,W
0287:  MOVWF  59
0288:  CALL   059
....................    digitalWrite(LCD_ENABLE_PIN, 1); 
0289:  MOVLW  40
028A:  MOVWF  58
028B:  MOVLW  01
028C:  MOVWF  59
028D:  CALL   059
....................    delay_us(100); 
028E:  MOVLW  20
028F:  MOVWF  77
0290:  DECFSZ 77,F
0291:  GOTO   290
0292:  GOTO   293
0293:  NOP
....................    digitalWrite(LCD_ENABLE_PIN, 0); 
0294:  MOVLW  40
0295:  MOVWF  58
0296:  CLRF   59
0297:  CALL   059
....................    delay_ms(1); 
0298:  MOVLW  01
0299:  MOVWF  57
029A:  CALL   024
.................... } 
....................  
....................  
.................... void LCD_setCursor(unsigned int8 posX, unsigned int8 posY){ 
*
01E5:  MOVF   00,W
01E6:  IORLW  80
01E7:  MOVWF  55
.................... char cursorPos[2][16] = {{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F}, 
....................                                  {0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F} 
....................                                 }; 
*
0199:  CLRF   35
019A:  MOVLW  01
019B:  MOVWF  36
019C:  MOVLW  02
019D:  MOVWF  37
019E:  MOVLW  03
019F:  MOVWF  38
01A0:  MOVLW  04
01A1:  MOVWF  39
01A2:  MOVLW  05
01A3:  MOVWF  3A
01A4:  MOVLW  06
01A5:  MOVWF  3B
01A6:  MOVLW  07
01A7:  MOVWF  3C
01A8:  MOVLW  08
01A9:  MOVWF  3D
01AA:  MOVLW  09
01AB:  MOVWF  3E
01AC:  MOVLW  0A
01AD:  MOVWF  3F
01AE:  MOVLW  0B
01AF:  MOVWF  40
01B0:  MOVLW  0C
01B1:  MOVWF  41
01B2:  MOVLW  0D
01B3:  MOVWF  42
01B4:  MOVLW  0E
01B5:  MOVWF  43
01B6:  MOVLW  0F
01B7:  MOVWF  44
01B8:  MOVLW  40
01B9:  MOVWF  45
01BA:  MOVLW  41
01BB:  MOVWF  46
01BC:  MOVLW  42
01BD:  MOVWF  47
01BE:  MOVLW  43
01BF:  MOVWF  48
01C0:  MOVLW  44
01C1:  MOVWF  49
01C2:  MOVLW  45
01C3:  MOVWF  4A
01C4:  MOVLW  46
01C5:  MOVWF  4B
01C6:  MOVLW  47
01C7:  MOVWF  4C
01C8:  MOVLW  48
01C9:  MOVWF  4D
01CA:  MOVLW  49
01CB:  MOVWF  4E
01CC:  MOVLW  4A
01CD:  MOVWF  4F
01CE:  MOVLW  4B
01CF:  MOVWF  50
01D0:  MOVLW  4C
01D1:  MOVWF  51
01D2:  MOVLW  4D
01D3:  MOVWF  52
01D4:  MOVLW  4E
01D5:  MOVWF  53
01D6:  MOVLW  4F
01D7:  MOVWF  54
01D8:  MOVLW  01
01D9:  SUBWF  34,W
01DA:  MOVWF  77
01DB:  SWAPF  77,W
01DC:  MOVWF  56
01DD:  MOVLW  F0
01DE:  ANDWF  56,F
01DF:  MOVLW  01
01E0:  SUBWF  33,W
01E1:  ADDWF  56,W
01E2:  ADDLW  35
01E3:  MOVWF  04
01E4:  BCF    03.7
....................    unsigned int8 cursorPosition = (cursorPos[posY - 1][PosX - 1]) | 0x80; 
....................    LCD_sendCmd(cursorPosition); 
*
01E8:  MOVF   55,W
01E9:  MOVWF  56
01EA:  CALL   078
01EB:  RETURN
.................... } 
....................  
.................... void LCD_BlinkON(unsigned int1 Blink){ 
....................    if(Blink == 1){ 
*
018D:  DECFSZ 33,W
018E:  GOTO   193
....................       LCD_sendCmd(0x0F); 
018F:  MOVLW  0F
0190:  MOVWF  56
0191:  CALL   078
....................    } 
0192:  GOTO   196
....................    else{ 
....................       LCD_sendCmd(0x0C); 
0193:  MOVLW  0C
0194:  MOVWF  56
0195:  CALL   078
....................    } 
0196:  BCF    0A.3
0197:  BCF    0A.4
0198:  GOTO   2CE (RETURN)
.................... } 
....................  
.................... void LCD_print(unsigned int8 *p){ 
*
01EC:  CLRF   37
....................    #define LCD_printString(str) LCD_print((unsigned int8 *)(str)) 
....................    unsigned int8 i = 0; 
....................    while(*(p+i) != 0) 
01ED:  MOVF   37,W
01EE:  ADDWF  35,W
01EF:  MOVWF  78
01F0:  MOVF   36,W
01F1:  MOVWF  7A
01F2:  BTFSC  03.0
01F3:  INCF   7A,F
01F4:  MOVF   78,W
01F5:  MOVWF  04
01F6:  BCF    03.7
01F7:  BTFSC  7A.0
01F8:  BSF    03.7
01F9:  MOVF   00,F
01FA:  BTFSC  03.2
01FB:  GOTO   29D
....................    { 
....................       LCD_sendChar(*(p+i)); 
01FC:  MOVF   37,W
01FD:  ADDWF  35,W
01FE:  MOVWF  78
01FF:  MOVF   36,W
0200:  MOVWF  7A
0201:  BTFSC  03.0
0202:  INCF   7A,F
0203:  MOVF   78,W
0204:  MOVWF  04
0205:  BCF    03.7
0206:  BTFSC  7A.0
0207:  BSF    03.7
0208:  MOVF   00,W
0209:  MOVWF  38
020A:  MOVF   38,W
020B:  MOVWF  39
....................       i++; 
*
029B:  INCF   37,F
029C:  GOTO   1ED
....................    }  
029D:  RETURN
.................... } 
.................... void LCD_printNumber(unsigned int8 Num){ 
....................    Num = Num | 0x30; 
....................     LCD_sendChar(Num); 
.................... } 
....................  
....................  
.................... /*void RDA_isr(void) 
.................... { 
....................    recevieData = getch(); 
....................    recevieData = recevieData - 48; 
....................    metalCheck = metalCheck + recevieData; 
....................    LCD_setCursor(11,1);  
....................    LCD_printNumber(metalCheck); 
....................    putc('1'); 
....................  
.................... } 
.................... */ 
.................... //--------------------------------------------End LCD_Func------------------------------------------------------------- 
....................  
.................... void main() 
029E:  MOVF   03,W
029F:  ANDLW  1F
02A0:  MOVWF  03
02A1:  BSF    03.5
02A2:  BSF    03.6
02A3:  BCF    07.3
02A4:  MOVLW  19
02A5:  BCF    03.6
02A6:  MOVWF  19
02A7:  MOVLW  A6
02A8:  MOVWF  18
02A9:  MOVLW  90
02AA:  BCF    03.5
02AB:  MOVWF  18
02AC:  CLRF   22
02AD:  CLRF   23
02AE:  MOVLW  FF
02AF:  MOVWF  24
02B0:  BSF    03.5
02B1:  BSF    03.6
02B2:  MOVF   09,W
02B3:  ANDLW  C0
02B4:  MOVWF  09
02B5:  BCF    03.6
02B6:  BCF    1F.4
02B7:  BCF    1F.5
02B8:  MOVLW  00
02B9:  BSF    03.6
02BA:  MOVWF  08
02BB:  BCF    03.5
02BC:  CLRF   07
02BD:  CLRF   08
02BE:  CLRF   09
02BF:  BCF    03.7
.................... { 
....................    enable_interrupts(INT_RDA); 
*
02C3:  BSF    03.5
02C4:  BSF    0C.5
....................    enable_interrupts(GLOBAL); 
02C5:  MOVLW  C0
02C6:  BCF    03.5
02C7:  IORWF  0B,F
....................     
....................    delay_ms(100); 
02C8:  MOVLW  64
02C9:  MOVWF  57
02CA:  CALL   024
....................    LCD_Initilize(); 
02CB:  GOTO   107
....................    LCD_BlinkON(0); 
02CC:  CLRF   33
02CD:  GOTO   18D
....................    LCD_setCursor(2,1);  
02CE:  MOVLW  02
02CF:  MOVWF  33
02D0:  MOVLW  01
02D1:  MOVWF  34
02D2:  CALL   199
....................    LCD_printString("Bluetooth Car"); 
02D3:  CLRF   78
02D4:  MOVLW  0E
02D5:  MOVWF  77
02D6:  MOVLW  25
02D7:  MOVWF  04
02D8:  BCF    03.7
02D9:  MOVF   78,W
02DA:  CALL   004
02DB:  MOVWF  00
02DC:  INCF   78,F
02DD:  INCF   04,F
02DE:  DECFSZ 77,F
02DF:  GOTO   2D9
02E0:  CLRF   36
02E1:  MOVLW  25
02E2:  MOVWF  35
02E3:  CALL   1EC
....................    LCD_setCursor(4,2);  
02E4:  MOVLW  04
02E5:  MOVWF  33
02E6:  MOVLW  02
02E7:  MOVWF  34
02E8:  CALL   199
....................    LCD_printString("PIC16F887"); 
02E9:  CLRF   78
02EA:  MOVLW  0A
02EB:  MOVWF  77
02EC:  MOVLW  25
02ED:  MOVWF  04
02EE:  BCF    03.7
02EF:  MOVF   78,W
02F0:  CALL   016
02F1:  MOVWF  00
02F2:  INCF   78,F
02F3:  INCF   04,F
02F4:  DECFSZ 77,F
02F5:  GOTO   2EF
02F6:  CLRF   36
02F7:  MOVLW  25
02F8:  MOVWF  35
02F9:  CALL   1EC
....................  
....................    while(TRUE) 
....................    {   
....................       if(input(Button_Up) == 0){ 
02FA:  BSF    24.0
02FB:  MOVF   24,W
02FC:  BSF    03.5
02FD:  MOVWF  07
02FE:  BCF    03.5
02FF:  BTFSC  07.0
0300:  GOTO   309
....................          putc('1'); 
0301:  MOVLW  31
0302:  BTFSS  0C.4
0303:  GOTO   302
0304:  MOVWF  19
....................          delay_ms(200); 
0305:  MOVLW  C8
0306:  MOVWF  57
0307:  CALL   024
....................       } 
0308:  GOTO   33A
....................       else if(input(Button_Down) == 0){ 
0309:  BSF    24.1
030A:  MOVF   24,W
030B:  BSF    03.5
030C:  MOVWF  07
030D:  BCF    03.5
030E:  BTFSC  07.1
030F:  GOTO   318
....................          putc('2'); 
0310:  MOVLW  32
0311:  BTFSS  0C.4
0312:  GOTO   311
0313:  MOVWF  19
....................          delay_ms(200); 
0314:  MOVLW  C8
0315:  MOVWF  57
0316:  CALL   024
....................       } 
0317:  GOTO   33A
....................       else if(input(Button_Left) == 0){ 
0318:  BSF    24.2
0319:  MOVF   24,W
031A:  BSF    03.5
031B:  MOVWF  07
031C:  BCF    03.5
031D:  BTFSC  07.2
031E:  GOTO   327
....................          putc('3'); 
031F:  MOVLW  33
0320:  BTFSS  0C.4
0321:  GOTO   320
0322:  MOVWF  19
....................  
....................          delay_ms(200); 
0323:  MOVLW  C8
0324:  MOVWF  57
0325:  CALL   024
....................       } 
0326:  GOTO   33A
....................       else if(input(Button_Right) == 0){ 
0327:  BSF    24.3
0328:  MOVF   24,W
0329:  BSF    03.5
032A:  MOVWF  07
032B:  BCF    03.5
032C:  BTFSC  07.3
032D:  GOTO   336
....................          putc('4'); 
032E:  MOVLW  34
032F:  BTFSS  0C.4
0330:  GOTO   32F
0331:  MOVWF  19
....................          delay_ms(200); 
0332:  MOVLW  C8
0333:  MOVWF  57
0334:  CALL   024
....................       } 
0335:  GOTO   33A
....................       else{ 
....................          putc('0'); 
0336:  MOVLW  30
0337:  BTFSS  0C.4
0338:  GOTO   337
0339:  MOVWF  19
....................       } 
033A:  GOTO   2FA
....................       } 
.................... }       
....................  
033B:  SLEEP
....................  
....................  

Configuration Fuses:
   Word  1: 2CE1   XT NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
